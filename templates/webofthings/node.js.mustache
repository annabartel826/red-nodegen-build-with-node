module.exports = function (RED) {
    "use strict";
    const request = require("request");
    const url = require('url');
    const HttpsProxyAgent = require('https-proxy-agent');
    const WebSocket = require('ws');
    const urltemplate = require('url-template');
 
    function normalizeTdForm(td) {
        function formconv(intr,f) {
            if (f && f.hasOwnProperty("href")) { f.href = url.resolve(baseUrl, f.href)}
            if (f && !f.hasOwnProperty("security")) {
                if (intr.hasOwnProperty("security")) {
                    f.security = intr.security;
                } else if (td.hasOwnProperty("security")) {
                    f.security = td.security;
                }
            }
            if (f && f.hasOwnProperty("rel")) {  
                if (Array.isArray(f.rel) && f.rel.length > 0) {
                    f.rel = f.rel[0];
                }
            }
            if (f && f.hasOwnProperty("op")) { // if op is array, select first element.
                if (Array.isArray(f.op) && f.op.length > 0) {
                    f.op = f.op[0];
                }
            }
            if (f && !f.hasOwnProperty("mediaType")) { f.mediaType = "application/json"; } // default value of mediaType is json
            return f;
        };
        const baseUrl = td.base || "";
        for (const p in td.properties) {
            let forms = td.properties[p].forms;
            if (forms) {
                td.properties[p].forms = forms.map((f) => formconv(td.properties[p], f))
                            .filter((f) => (f.hasOwnProperty("href") && (f.href.match(/^https?:/) || 
                                    f.href.match(/^wss?:/))));                       
            }
            if (!td.properties[p].hasOwnProperty("observable")) { td.properties[p].observable = false;}
            if (!td.properties[p].hasOwnProperty("writable")) { td.properties[p].writable = false;}
        }
        for (const a in td.actions) {
            let forms = td.actions[a].forms;
            if (forms) {
                td.actions[a].forms = forms.map((f) => formconv(td.actions[a], f))
                            .filter((f) => (f.hasOwnProperty("href") && (f.href.match(/^https?:/) || 
                                    f.href.match(/^wss?:/))));
            }
        }
        for (const e in td.events) {
            let forms = td.events[e].forms;
            if (forms) {
                td.events[e].forms = forms.map((f) => formconv(td.events[e], f))
                            .filter((f) => (f.hasOwnProperty("href") && (f.href.match(/^https?:/) || 
                                   f.href.match(/^wss?:/))));
            }
        }
        return td;
    }

    function formSelection(interaction, forms) {
        if (interaction === "property-read") {
            for (const f of forms) {
                if ((f.hasOwnProperty("rel") && f.rel.match(/^readproperty$/i)) ||
                    (f.hasOwnProperty("op") && f.op.match(/^readproperty$/i))) {
                    return f;
                }
            }
            return forms[0];
        } else if (interaction === "property-write") {
            for (const f of forms) {
                if ((f.hasOwnProperty("rel") && f.rel.match(/^writeproperty$/i)) ||
                    (f.hasOwnProperty("op") && f.op.match(/^writeproperty$/i))) {
                    return f;
                }
            }
            return forms[0];
        } else if (interaction === "property-observe" || interaction === "event") {
            // First priority: websocket
            for (const f of forms) {
                if (f.hasOwnProperty("href") && f.href.match(/^wss?:/)) {
                    return f;
                }
            }
            // Second priority: longpoll
            for (const f of forms) {
                if (f.hasOwnProperty("subProtocol") && f.subProtocol.match(/^longpoll$/i)) {
                    return f;
                }
            }
            // Third priority: observeproperty
            for (const f of forms) {
                if ((f.hasOwnProperty("rel") && f.rel.match(/^observeproperty$/i)) ||
                    (f.hasOwnProperty("op") && f.op.match(/^observeproperty$/i))) { 
                    return f;
                }
            }
            return forms[0];
        } else if (interaction === "action") {
            return forms[0];
        } else {
            return forms[0];
        }
    }

    function extractTemplate(href, context={}) {
        return urltemplate.parse(href).expand(context);
    }

    function bindingWebSocket(node, form, options={}) {
        let ws;
        let reconnectTimeout;
        let needReconnect = false;
        const setupWsClient = () => {
            let wsoptions = {};
            if (process.env.http_proxy) {
                const agoptions = url.parse(process.env.http_proxy);
                const agent = new HttpsProxyAgent(agoptions);
                wsoptions = {agent: agent};
            }
            if (options.hasOwnProperty("auth") && 
                (options.auth.hasOwnProperty("user") || options.auth.hasOwnProperty("bearer"))) {
                wsoptions.auth = options.auth;
            }
            node.status({fill:"yellow",shape:"dot",text:"WS Connecting..."});
            needReconnect = true;
            const href = extractTemplate(form.href,options.urivars);
            ws = new WebSocket(href, wsoptions);
            node.trace(`Connecting websocket: ${form.href}`);

            ws.on('open', () => {
                node.status({fill:"green",shape:"dot",text:"WS Connected"});
                node.trace('websocket opened.');
            });
            ws.on('close', (code, reason) => {
                node.status({});
                node.trace(`websocket closed (code=${code}, reason=${reason})`); 
                if (needReconnect) {
                    node.status({fill:"orange",shape:"dot",text:`WS Reconnecting...`});
                    reconnectTimeout = setTimeout(setupWsClient, 5000);
                }
            });
            ws.on('error', (error) => {
                node.status({fill:"red",shape:"dot",text:`WS Error: ${error}`});
                node.warn(`websocket error: ${error}`);
            });
            ws.on('message', (data) => {
                node.status({fill:"green",shape:"dot",text:"WS OK"});
                const msg = {};
                if (form.mediaType === "application/json") {
                    try {
                        msg.payload = JSON.parse(data);
                    } catch(e) {
                        msg.payload = data;
                    }
                } else {
                    msg.payload = data;
                }
                node.send(msg)
            });
        }
        setupWsClient();
        node.on('close', () => {
            node.trace('Close node');
            clearTimeout(reconnectTimeout);
            needReconnect = false;
            try {
                ws.close();
            } catch (err) {

            }
            node.status({});
        });
    }

    function bindingLongPoll(node, form, options={}) {
        let reqObj;
        let needReconnect = false;
        let reconnectTimeout;
        const setupLPClient = () => { 
            const reqoptions = {};
            reqoptions.uri = extractTemplate(form.href, options.urivars);
            reqoptions.rejectUnauthorized = false;
            // reqoptions.timeout = 60000; 
            if (options && options.auth && (options.auth.user || options.auth.bearer)) {
                reqoptions.auth = options.auth;
            }
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "GET";
            node.trace(`LongPoll Request options: ${JSON.stringify(reqoptions)}`);
            needReconnect = true;
            reqObj = request(reqoptions, (err, res, body) => {
                if (err) {
                    const msg = {};
                    msg.payload = `${err.toString()}: ${reqoptions.uri}`;
                    msg.statusCode = err.code;
                    node.status({fill:"yellow",shape:"dot",text:"Polling error"});
                    node.send(msg);
                    if (needReconnect) {
                        reconnectTimeout = setTimeout(setupLPClient, 5000);
                    }
                } else {
                    const msg = {};
                    node.status({fill:"green",shape:"dot",text:"OK"});
                    msg.statusCode = res.statusCode;
                    msg.headers = res.headers;
                    msg.responseUrl = res.request.uri.href;
                    if (form.mediaType === "application/json") {
                        try {
                            msg.payload = JSON.parse(body);
                        } catch(e) {
                            msg.payload = body;
                        }
                    } else {
                        msg.payload = body;
                    }
                    // TODO: validation of return value    
                    node.send(msg);
                    if (needReconnect) {
                        reconnectTimeout = setTimeout(setupLPClient, 5000);
                    }
                }
            });
            node.status({fill:"green",shape:"dot",text:"Connecting..."});
        }
        setupLPClient();
        node.on("close", () => {
            node.status({});
            needReconnect = false;
            clearTimeout(reconnectTimeout);
            if (reqObj) {
                reqObj.abort();
            } 
        });
    }

    function bindingHttp(node, form, options={}) { // options.interaction, options.auth, options.reqbody, options.msg
        const msg = options.msg || {};
        const reqoptions = {}; 
        reqoptions.uri = extractTemplate(form.href, options.urivars);
        reqoptions.rejectUnauthorized = false;
        if (options.hasOwnProperty("auth") && 
            (options.auth.hasOwnProperty("user") || options.auth.hasOwnProperty("bearer"))) {
            reqoptions.auth = options.auth;
        }
        if (options.interaction === "property-read") {
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "GET";
        } else if (options.interaction === "property-write") {
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "PUT";
            reqoptions.json = form.mediaType === "application/json";
            reqoptions.body = options.reqbody;
            reqoptions.headers = {'Content-Type': form.mediaType};
        } else { // assume "action"
            reqoptions.method = form.hasOwnProperty("http:methodName") ? form["http:methodName"] : "POST";
            reqoptions.json = form.mediaType === "application/json";
            reqoptions.body = options.reqbody;
            reqoptions.headers = {'Content-Type': form.mediaType};
        }
        node.trace(`HTTP request options: ${JSON.stringify(reqoptions)}`);
        request(reqoptions, (err, res, body) => {
            if (err) {
                msg.payload = `${err.toString()}: ${reqoptions.uri}`;
                msg.statusCode = err.code;
                node.send(msg); 
            } else {
                msg.statusCode = res.statusCode;
                msg.headers = res.headers;
                msg.responseUrl = res.request.uri.href;
                if (form.mediaType === "application/json") {
                    try {
                        msg.payload = JSON.parse(body);
                    } catch(e) {
                        msg.payload = body;
                    }
                } else {
                    msg.payload = body;
                }
                // TODO: validation of return value    
                node.send(msg); 
            }
        });
    }


    function Node(config) {
        RED.nodes.createNode(this, config);
        const node = this;
        node.interactiontype = config.interactiontype;
        node.propname = config.propname;
        node.proptype = config.proptype;
        node.actname = config.actname;
        node.evname = config.evname;
        node.status({});
        node.debug(`node config: ${JSON.stringify(node)}`);
        const username = node.credentials.username;
        const password = node.credentials.password;
        const token = node.credentials.token;
        const auth = {};
        // if username and password is set, use it.
        if (username && password) {
            auth.user = username;
            auth.pass = password;
            auth.sendImmediately = true;
        } else if (token) {
            auth.bearer = token
            auth.sendImmediately = true;
        }
     
        node.td = JSON.parse(`{{&tdstr}}`);
        const normTd = normalizeTdForm(node.td);
        if (node.interactiontype === "property") {
            if (node.proptype === "read") {
                node.on("input", (msg) => {
                    const prop = normTd.properties[node.propname];
                    const form = formSelection("property-read", prop.forms);
                    const urivars = prop.hasOwnProperty("uriVariables") ? msg.payload : {};
                    bindingHttp(node, form, {interaction:"property-read", auth, msg, urivars});
                });
            } else if (node.proptype === "write") {
                node.on("input", (msg) => {
                    const prop = normTd.properties[node.propname];
                    const form = formSelection("property-write", prop.forms);
                    // URI template is not supported, because 'write' doesn't use GET method.
                    bindingHttp(node, form, {interaction: "property-write", auth, msg, reqbody: msg.payload});    
                });
            } else if (node.proptype === "observe") {
                const prop = normTd.properties[node.propname];
                const form = formSelection("property-observe", prop.forms);
                const urivars = prop.hasOwnProperty("uriVariables") ? msg.payload : {};
                if (form.href.match(/^wss?:/)) { // websocket
                    bindingWebSocket(node, form, {auth, urivars});
                } else { // long polling
                    bindingLongPoll(node, form, {auth, urivars});
                }               
            }
        } else if (node.interactiontype === "action") {
            node.on("input", (msg) => {
                const act = normTd.actions[node.actname];
                const form = formSelection("action", act.forms);
                const urivars = act.hasOwnProperty("uriVariables") ? msg.payload : {};  
                bindingHttp(node, form, {interaction: "action", auth, msg, urivars, reqbody:msg.payload});                
            });
        } else if (node.interactiontype === "event") {
            const ev = normTd.events[node.evname];
            const form = formSelection("event", ev.forms);
            const urivars = ev.hasOwnProperty("uriVariables") ? msg.payload : {};
            if (form.href.match(/^wss?:/)) { // websocket
                bindingWebSocket(node, form, {auth, urivars});
            } else { // long polling
                bindingLongPoll(node, form, {auth, urivars});
            }               
        }
    };
    RED.nodes.registerType("{{&nodeName}}", Node, {
        credentials: {
            token: {type:"password"},
            username: {type:"text"},
            password: {type:"password"}
        }
    });
};